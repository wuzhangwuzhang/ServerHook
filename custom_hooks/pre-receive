#!/usr/bin/env bash
#pre-receive script
#set -x #for debugging

keyword_list=(
    '^fix'          #bug修复
	'^Fix'          #bug修复
    '^fixed'        #bug修复
    '^Fixed'        #bug修复
    '^task'         #完成任务
	'^Task'         #完成任务
	'^subTask'      #完成子任务
	'^SubTask'      #完成子任务
    '^test'         #测试用例
    '^perf'         #性能    
    '^docs'         #文档
    '^chore'        #其它
    '^depc'         #依赖
    '^[ci skip]'    #自动化
)

check_branchs=(
	#"dev"				#dev
	#"master"			#master
	#"oversearelease"	#oversearelease
)

# Concatenate keyword_list
separator="|"
formatStr=$( printf "${separator}%s" "${keyword_list[@]}" )
regex="$( printf "${separator}%s" "${keyword_list[@]}" )"
# remove leading separator
regex="${regex:${#separator}}"


flag=0
isFeatureBranch=false

validate_ref()
{
    # --- Arguments
    oldrev=$(git rev-parse $1)
    newrev=$(git rev-parse $2)
    refname="$3"
	#echo 'oldrev:'$oldrev
	#echo 'newrev:'$newrev
	#echo 'refname:'$refname

	IFS='/' read -ra arr <<< "$refname"
	#echo "分支层级深度:${#arr[@]}"
	if [ "${#arr[@]}" -ge 5 ]; then
	  	#echo "当前是开发分支提交"
		isFeatureBranch=true
	fi

	#echo "当前推送的分支:$refname"
	branch="${arr[-1]}"
	#echo "branch:${branch}"
	# 使用循环遍历整个数组，并判断每个元素是否包含 "err" 子字符串
	index=0
	for element in "${check_branchs[@]}"; do
		let index++ 
		if [[ "$element" == $branch ]]; then
			#echo "$element contains $branch index:${index}."
			break
		fi
	done

	#echo $index  ${#arr[@]}  $isFeatureBranch
	if [ $isFeatureBranch != true ]; then
		if [ ${index} == ${#arr[@]} ]; then
			echo "no need check"
			exit 0
		fi
	fi

    commitList=`git rev-list $oldrev..$newrev`
    split=($commitList)
	length=${#split[@]}
    if [ $length -gt 0 ];then
        for s in ${split[@]}
        do
            msg=`git cat-file commit $s | sed '1,/^$/d'`
			#echo "提交日志:$msg" 
            if [ ${#msg} -lt 5 ];then
				echo "提交日志格式不正确:$msg"
                exit 1
            else				
				#trimedStr=$(echo -e $msg | sed ':a;N;$!ba;s/\n//g')
				#echo "去除换行符:" $trimedStr
				if [[ $msg == *"Admin"* ]] || [[ $msg == *"admin"* ]]; then
					echo "管理员特批提交"
	                flag=0
	                exit 0
				elif [[ $msg == *"Merge"* ]] || [[ $msg == *"merge"* ]]; then
					# split string into lines
					IFS=$'\n' read -d '' -ra lines <<< "$msg"
					#echo "lines length:${#lines[@]}"
					if [ "${#lines[@]}" -eq 3 ]; then
						mergeBranchInfo=${lines[0]}
						commitLogInfo=${lines[1]}
						mergeLog=${lines[2]}
						echo "[branchInfo]:$mergeBranchInfo"
						echo "[commitInfo]:$commitLogInfo"
						echo "[mergeInfo]:$mergeLog"
					elif [ "${#lines[@]}" -eq 4 ]; then
						mergeBranchInfo=${lines[0]}
						commitLogInfo=${lines[1]}
						mergeLog=${lines[3]}
						echo "[branchInfo]:$mergeBranchInfo"
						echo "[commitInfo]:$commitLogInfo"
						echo "[mergeInfo]:$mergeLog"
					fi

					
					trimedStr=$(echo -e $commitLogInfo | sed ':a;N;$!ba;s/\n//g')
					#echo "[Trim Log Blank]:" $trimedStr

					keyword=$(echo "$trimedStr" | awk '{print $1}')
					#echo "[keyword]:$keyword"

					regex_jriaId='SLPK-[0-9]+'

					if [[ $trimedStr =~ $regex_jriaId ]]; then
						jiraId=${BASH_REMATCH[0]}
						#echo "[jiraId]:$jiraId"
					else
						#echo "No jiraId found in merge log:$msg "
						continue
					fi

					# define regular expression
					regex_mergeId='![0-9]+'

					# check if there is a match
					if [[ $mergeLog =~ $regex_mergeId ]]; then
						# save matched string to a variable
						mergeId=${BASH_REMATCH[0]}
						mergeId=${mergeId:1}
						mergeUrl="https://gitlab.uuzu.com/xiyou/workspace/-/merge_requests/$mergeId"
						#echo "merge url: $mergeUrl"
					else
						echo "Not find mergeId"
					fi

					desc="问题描述"
					#echo "【提交日志】keyword:$keyword jiraId:$jiraId desc:$desc refname:$refname mergeUrl: $mergeUrl"
					python "custom_hooks/jiraCheck.py" $keyword $jiraId $refname $mergeUrl
		            flag=$?		
					return
				else													
					IFS=' ' read -r keyword jiraId desc review<<<"$msg"					
		            #echo '【提交日志】keyword:'$keyword 'jiraId:'$jiraId 'desc:'$desc 'review:'$review
					match=`echo $keyword | grep -nE "(${regex})"`
		            #echo 'match info:'$match
		            if [[ "${match}" == "" ]]; then
						echo "提交不通过:" $msg
						echo '**************************************************'
		                echo '*     提交日志格式有误,拒绝提交,任务&缺陷提交示例如下		'
						echo '* task SLPK-6666 这是一个任务的提交描述 Review:宣宣   '
						echo '* fix SLPK-8888 这是一个bug修复的描述 Review:宣宣  '
						echo '**************************************************'
		                exit 1
		            fi

					regex_jriaId='SLPK-[0-9]+'
					if [[ $msg =~ $regex_jriaId ]]; then
						jiraId=${BASH_REMATCH[0]}
						#echo "[jiraId]:$jiraId"
					fi
	            fi

				python "custom_hooks/jiraCheck.py" $keyword $jiraId $refname
	            flag=$?
                if (( $flag != 0 )); then
                    exit 1
                fi            
            fi
        done
    fi
}

#先拉取CDN配置的钩子检查开关及配置的检查分支
result=`curl -s -H "Content-Type: application/text" "http://10.18.41.29/githook/hookSwitch.txt"`
#echo "result:$result"
# 匹配包含 "404 Not Found" 文件不存在
if echo "${result}" | grep -q "404 Not Found"; then
 	echo "http://10.18.41.29/githook/hookSwitch.txt,钩子配置文件不存在,不检查."
	exit 0
fi


if echo "${result}" | grep -q "401 Authorization Required"; then
 	echo "ttp://10.18.41.29/githook/hookSwitch.txt,没权限拉取钩子配置文件,不检查."
	exit 0
fi

# 文件存在，解析参数是否开启钩子和配置的检查分支
IFS=$'\n' read -d '' -ra lines <<< "$result"
switch=${lines[0]}
branchCfg=${lines[1]}

# 钩子未开启检查
if [ ${switch} -eq 0 ]; then
	echo "http://10.18.41.29/githook/hookSwitch.txt,钩子配置检查处于关闭,不检查."
	exit 0
fi

# 钩子开启检查，获取解析需要检查的分支
echo "钩子开关(1:检查 0:不检查):${switch} 已配置需要检查的分支:${branchCfg} (可动态调整)"
IFS=$'|' read -d '' -ra branchs <<< "$branchCfg"
if [ ${#branchs} -gt 0 ];then
	index=0
	for s in ${branchs[@]}
	do
		let index++
		check_branchs[${index}]=$s
	done
fi

read oldrev newrev refname
validate_ref $oldrev $newrev $refname

if [ ${flag} -eq 1 ];then
  	exit 1
else
	exit 0
fi
